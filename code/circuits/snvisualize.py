from __future__ import annotations

import sys
from enum import Enum

from typing import Optional, Literal
from collections.abc import Iterable

from .visualize import base as vis, positioning
from .sncircuit import SNCreate, token_re, incd_in_re, incd_out_re, incd_token_re, circuit_re


class ElementType(Enum):
    neuron = 0
    input = 1
    output = 2


class SNCreateVisual:
    def __init__(
        self,
        sncreate: SNCreate,
        graph_drawing: positioning.SugiyamaGraphDrawing | None = None
    ):
        self._sncreate = sncreate
        self._size: Optional[vis.Size] = None
        self._inputs: list[vis.Pos] = []
        self._outputs: list[vis.Pos] = []
        self._nodes: dict[str, vis.Node] = {}
        self._includes: dict[str, vis.Pos] = {}
        self._arrows: dict[str, dict[str, list[vis.Pos]]] = {}
        self._include_visuals: dict[str, vis.CircuitDisplay] = {}
        self.__circuit_display: Optional[vis.CircuitDisplay] = None
        # These parameters only matter for autogenerated figures
        self._graph_drawing = graph_drawing
        self._x_axis_zoom = 1.5
        self._input_output_sep = 2.0

    def set_graph_drawing_params(
        self,
        x_axis_zoom: float | None = None,
        input_output_sep: float | None = None
    ) -> None:
        if x_axis_zoom is not None:
            self._x_axis_zoom = x_axis_zoom
        if input_output_sep is not None:
            self._input_output_sep = input_output_sep

    def _get_path_for_connection(self, from_: str, to: str) -> Optional[list[vis.Pos]]:
        if from_ in self._arrows and to in self._arrows[from_]:
            return self._arrows[from_][to]
        return None

    def _check_all_neurons_pos_defined(self) -> None:
        neurons = {n for n in self._sncreate._neurons if token_re.fullmatch(n) is not None}
        pos_not_defined = neurons - set(self._nodes)
        if pos_not_defined:
            raise Exception("Position for some neurons not yet defined. Not defined "
                            f"for: {pos_not_defined}")

    def _check_all_includes_are_defined(self) -> None:
        pos_not_defined = set(self._sncreate._include_circuit_names) - set(self._includes)
        if pos_not_defined:
            raise Exception("Position for some included circuits not yet defined. Not "
                            f"defined for: {pos_not_defined}")

    def _find_element_pos(
        self,
        name: str,
        ignore_inc_box: bool = False
    ) -> tuple[vis.Pos, ElementType]:
        """
        Find neuron, input or output position for a given name
        """
        match_incd_out = incd_out_re.match(name)
        match_incd_in = incd_in_re.match(name)
        match_incd = incd_token_re.match(name)
        match_neuron = token_re.match(name)
        weird_element = False

        any_match_inc = match_incd_out or match_incd_in or match_incd
        # The element is part of an include
        if not ignore_inc_box and any_match_inc:
            # extract include name and neuron name inside the included circuit
            name_inc, name_elem = any_match_inc[1], any_match_inc[2]
            include_ = self._get_include_visual(name_inc)
            include_offset = self._includes[name_inc]
            include_obj = self._sncreate._include_circuit_obj[name_inc]

            # The element is an output inside an include
            if match_incd_out:
                # extract include and output id from out_name
                out_i = int(name_elem)
                pos = include_offset + include_.outputs[out_i]
                elem_type = ElementType.output
            # The element is an output inside an include
            elif match_incd_in:
                # extract include and output id from out_name
                in_i = int(name_elem)
                pos = include_offset + include_.outputs[in_i]
                elem_type = ElementType.input
            # The element is a neuron inside an included circuit
            elif match_incd:
                # finding specific neuron position inside the included circuit
                if name_elem in include_obj.ids_to_int:
                    neu_i = include_obj.ids_to_int[name_elem]
                    pos = include_offset + include_.nodes[neu_i]
                    elem_type = ElementType.neuron
                else:
                    assert name_elem in include_obj.inputs_id
                    in_i = include_obj.inputs_id[name_elem]
                    pos = include_offset + include_.inputs[in_i]
                    elem_type = ElementType.input
            else:
                weird_element = True
        # The element is a neuron defined by the top circuit
        elif (ignore_inc_box and any_match_inc) or match_neuron:
            assert name in self._nodes, f"`{name}` is not a neuron id"
            pos = vis.Pos(*self._nodes[name])
            elem_type = ElementType.neuron
        else:
            weird_element = True

        if weird_element:
            raise Exception(f"This is weird, `{name}` doesn't correspond to a neuron in "
                            "the circuit nor the included circuits")

        return pos, elem_type

    def _find_neurons_connected_to_input(self, input_inc: str) -> list[str]:
        match_incd_in = incd_token_re.match(input_inc)
        if match_incd_in:
            return list(self._sncreate._include_inputs[input_inc])
        else:
            raise Exception(f"Input name to an included circuit `{input_inc}` is not valid")

    def _find_neurons_connected_to_output(self, out_set: Iterable[str]) -> list[str]:
        out_list: list[str] = []
        for out_name in out_set:
            if incd_out_re.match(out_name):
                out_list.extend(self._sncreate._include_output_aliases[out_name])
            else:
                out_list.append(out_name)
        return out_list

    def _add_connections_from_inputs(
        self,
        connections: list[vis.Connection],
        ignore_inc_box: bool = False
    ) -> None:
        for i, (name_in, (synaps, to_inputs)) in enumerate(self._sncreate._inputs.items()):
            # connections to neurons
            connections.extend(
                self._connection_for(i, syn_name, ElementType.input, ElementType.neuron,
                                     ignore_inc_box)
                for syn_name in synaps
            )

            if ignore_inc_box:
                connections.extend(
                    self._connection_for(i, neuron_in, ElementType.input,
                                         ignore_inc_box=True)
                    for to_in in to_inputs
                    for neuron_in in self._find_neurons_connected_to_input(to_in)
                )
            else:
                # connections to inputs from includes
                connections.extend(
                    self._connection_for(i, to_in, ElementType.input)
                    for to_in in to_inputs
                )

    def _add_connections_for_outputs(
        self,
        connections: list[vis.Connection],
        ignore_inc_box: bool = False
    ) -> None:
        if ignore_inc_box:
            connections.extend(
                self._connection_for(out_name, i,
                                     (ElementType.neuron, ElementType.output),
                                     ElementType.output,
                                     ignore_inc_box)
                for i, out_set in enumerate(self._sncreate._outputs)
                for out_name in self._find_neurons_connected_to_output(out_set)
            )
        else:
            connections.extend(
                self._connection_for(out_name, i,
                                     (ElementType.neuron, ElementType.output),
                                     ElementType.output)
                for i, out_set in enumerate(self._sncreate._outputs)
                for out_name in out_set
            )

    def _add_connections_from_neurons(
        self, connections: list[vis.Connection],
        ignore_inc_box: bool = False
    ) -> None:
        # creating connections between neurons
        for neu_name, (neu_params, synaps, to_inputs) \
                in self._sncreate._neurons.items():

            # only neurons defined in circuit are worth adding
            match = token_re.match(neu_name)
            if not ignore_inc_box and match is None:
                continue

            # connections to other neurons
            connections.extend(
                self._connection_for(neu_name, syn_name, ElementType.neuron, ElementType.neuron,
                                     ignore_inc_box)
                for syn_name in synaps
            )

            if ignore_inc_box:
                # connections to inputs from includes
                connections.extend(
                    self._connection_for(neu_name, neuron_in, ElementType.neuron,
                                         ElementType.neuron, ignore_inc_box)
                    for to_in in to_inputs
                    for neuron_in in self._find_neurons_connected_to_input(to_in)
                )
            else:
                # connections to inputs from includes
                connections.extend(
                    self._connection_for(neu_name, to_in, ElementType.neuron, ElementType.input)
                    for to_in in to_inputs
                )

    def _add_connections_by_explicitely_def_conns(
        self, connections: list[vis.Connection],
        ignore_inc_box: bool = False
    ) -> None:
        # creating custom connections
        connections.extend(
            self._connection_for(elem_name, conn, ignore_inc_box=ignore_inc_box)
            for elem_name, elem_conns in self._sncreate._connections.items()
            for conn, _ in elem_conns
        )

    def _find_element_pos_restricted_to_type(
        self,
        elem: str | int,
        elem_type: Optional[tuple[ElementType, ...]],
        ignore_inc_box: bool
    ) -> tuple[str, vis.Pos, ElementType]:
        if isinstance(elem, str):
            pos, elem_t = self._find_element_pos(elem, ignore_inc_box)
        else:  # isinstance(from_, int)
            assert elem_type is not None and len(elem_type) == 1 \
                and elem_type[0] != ElementType.neuron, \
                "If the element is an int, the type of the element must be either " \
                f"`input` or `output`, but it is `{elem_type}`"

            if elem_type[0] == ElementType.input:
                pos = self._inputs[elem]
                elem = f"in_{elem}"
                # elem = list(self._sncreate._inputs.keys())[elem]
            else:  # elem_type[0] == ElementType.output:
                pos = self._outputs[elem]
                elem = f"out_{elem}"
            elem_t = elem_type[0]

        # This should never be triggered if all the other checks are in place. It helps
        # debugging inconsistencies
        if elem_type and elem_t not in elem_type:
            raise Exception(f"`{elem}` should be of type {elem_type} but it is "
                            f"of type {elem_t}")
        return elem, pos, elem_t

    def _connection_for(
        self,
        from_: str | int,
        to: str | int,
        from_type: ElementType | tuple[ElementType, ...] | None = None,
        to_type: ElementType | tuple[ElementType, ...] | None = None,
        ignore_inc_box: bool = False
    ) -> vis.Connection:
        # Converting from_type and to_type into tuples
        if isinstance(from_type, ElementType):
            from_type = (from_type,)
        if isinstance(to_type, ElementType):
            to_type = (to_type,)

        # Actual code to elements positions!
        from_, from_pos, from_t = self._find_element_pos_restricted_to_type(
            from_, from_type, ignore_inc_box)
        to, to_pos, to_t = self._find_element_pos_restricted_to_type(
            to, to_type, ignore_inc_box)

        return vis.straight_line_connection(
            from_=from_pos,
            to=to_pos,
            from_size=0.5 if from_t == ElementType.neuron else 0.125,
            to_size=0.5 if to_t == ElementType.neuron else 0.125,
            path=self._get_path_for_connection(from_, to)
        )

    def _get_include_visual(self, name_inc: str) -> vis.CircuitDisplay:
        if name_inc not in self._include_visuals:
            raise Exception(f"No visuals provided for include {name_inc}")
        return self._include_visuals[name_inc]

    def _get_graph_drawing(self) -> positioning.SugiyamaGraphDrawing:
        if self._graph_drawing is None:
            return positioning.SugiyamaGraphDrawing(
                remove_cycles=positioning.RemoveCycleDFS(reverse=False),
                layer_assignment=positioning.LayerAssignmentCoffmanGraham(
                    w=2, crossings_in_layer=1
                ),
                reuse_dummy_nodes=True
            )
        return self._graph_drawing

    def _use_graph_drawing_to_fill_in_params(self) -> None:
        # Defining graph from circuit data
        circuit = self._sncreate.circuit
        n_inputs = len(circuit.inputs)
        n_outputs = len(circuit.outputs)

        max_neu_id = circuit.num_neurons + 10
        input_nodes = list(range(max_neu_id, max_neu_id + n_inputs))
        max_neu_id += n_inputs
        output_nodes = list(range(max_neu_id, max_neu_id + n_outputs))

        # Extending edges with input and output connections
        edges: dict[int, set[int]] = \
            {n: set(synapses) for n, (_, synapses) in enumerate(circuit.neurons)} \
            | {n: set(synapses) for n, synapses in zip(input_nodes, circuit.inputs)} \
            | {n: set() for n in output_nodes}
        for out, neurs in zip(output_nodes, circuit.outputs):
            for n in neurs:
                edges[n].add(out)
        graph = positioning.Graph(
            vertices=set(range(circuit.num_neurons)) | set(input_nodes) | set(output_nodes),
            edges=edges
        )
        pretty_g = self._get_graph_drawing().find_pos(
            graph,
            inputs=input_nodes if input_nodes else None,
            outputs=output_nodes if output_nodes else None
        )

        ints_to_id = {i: id for id, i in circuit.ids_to_int.items()} \
            | {n: f'in_{i}' for i, n in enumerate(input_nodes)} \
            | {n: f'out_{i}' for i, n in enumerate(output_nodes)}
        ignore_nodes = set(input_nodes) | set(output_nodes)

        x_shift = -1 if input_nodes else 0

        # Converting positions defined by graph drawing algorithm into
        # coordinates for SNCircuit to present
        zoom = self._x_axis_zoom
        sep = self._input_output_sep
        self._nodes = {
            ints_to_id[v]: vis.Node((pos[0] + x_shift) * zoom + sep, pos[1] * 1.5 + 1)
            for v, pos in pretty_g.vertices.items()
            if v not in ignore_nodes}
        self._arrows = {}
        for v, ws in pretty_g.edges.items():
            for w, path in ws:
                # ignoring connections that don't have intermediate steps
                if path:
                    from_ = ints_to_id[v]
                    if from_ not in self._arrows:
                        self._arrows[from_] = {}
                    self._arrows[from_][ints_to_id[w]] = [
                        vis.Pos((pos[0] + x_shift) * zoom + sep, pos[1] * 1.5 + 1)
                        for pos in path]

        out_shift = -1 if output_nodes else 0
        self._size = vis.Size(
            (pretty_g.width + x_shift + out_shift - 1) * zoom + 2*sep,
            pretty_g.height * 1.5 + .5)

        n_inputs = len(self._sncreate._inputs)
        n_outputs = len(self._sncreate._outputs)
        self._inputs = [vis.Pos(0, i * 1.5 + 1) for i in range(n_inputs)]
        self._outputs = [vis.Pos(self._size.x, i * 1.5 + 1) for i in range(n_outputs)]

    def generate(
        self,
        mode: Literal['auto', 'manual', 'empty'] | None = None
    ) -> vis.CircuitDisplay:
        if self.__circuit_display is not None:
            return self.__circuit_display
        if mode is None:
            mode = 'manual' if self._nodes or self._includes else 'empty'

        auto = False
        # Filling in parameters automatically if auto mode has been selected
        if mode == 'auto':
            if self._nodes or self._includes:
                raise Exception("No node or include location can be assigned in `auto` mode")
            self._use_graph_drawing_to_fill_in_params()
            auto = True
        elif mode == 'manual':
            # all nodes and includes must be defined
            self._check_all_includes_are_defined()
            self._check_all_neurons_pos_defined()

        # Defining extra parameters
        n_inputs = len(self._sncreate._inputs)
        n_outputs = len(self._sncreate._outputs)
        size = vis.Size(1, max(n_inputs, n_outputs)) if self._size is None else self._size
        if not self._inputs:
            self._inputs = [vis.Pos(0, i + 0.5) for i in range(n_inputs)]
        else:
            assert len(self._inputs) == len(self._sncreate._inputs)
        if not self._outputs:
            self._outputs = [vis.Pos(size.x, i + 0.5) for i in range(n_outputs)]
        else:
            assert len(self._outputs) == len(self._sncreate._outputs)

        nodes_pos = {}
        connections: list[vis.Connection] = []
        includes: list[tuple[vis.Pos, vis.CircuitDisplay]] = []

        if mode == 'manual':
            includes = [(pos_in, self._get_include_visual(name_in))
                        for name_in, pos_in in self._includes.items()]

        if mode != 'empty':
            # defining position of nodes and includes
            nodes_pos = {self._sncreate.circuit.ids_to_int[name]: pos
                         for name, pos in self._nodes.items()}

            # creating connections from inputs, to outputs, between neurons and includes
            self._add_connections_from_inputs(connections, ignore_inc_box=auto)
            self._add_connections_for_outputs(connections, ignore_inc_box=auto)
            self._add_connections_from_neurons(connections, ignore_inc_box=auto)
            self._add_connections_by_explicitely_def_conns(connections, ignore_inc_box=auto)

        self.__circuit_display = vis.CircuitDisplay(
            name=None,
            size=size,
            nodes=nodes_pos,
            inputs=self._inputs,
            outputs=self._outputs,
            connections=connections,
            includes=includes
        )

        return self.__circuit_display

    def def_node_pos(self, name: str, pos: tuple[float, float]) -> None:
        self.__visual = None
        match = token_re.fullmatch(name)
        if match is None:
            raise ValueError(f"`{name}` is not a valid neuron name")
        if name not in self._sncreate._neurons:
            raise ValueError(f"Neuron `{name}` has not been defined in circuit")
        self._nodes[name] = vis.Node(*pos)

    def def_include_pos(self, name: str, pos: tuple[float, float]) -> None:
        self.__visual = None
        match = circuit_re.fullmatch(name)
        if match is None:
            raise ValueError(f"`{name}` is not a valid circuit include name")
        if name not in self._sncreate._include_circuit_names:
            raise ValueError(f"No circuit named `{name}` has been included. "
                             "Names of included circuits: "
                             f"{self._sncreate._include_circuit_names}")
        self._includes[name] = vis.Pos(*pos)

    def def_size(self, width: float, height: float) -> None:
        self.__visual = None
        assert width > 0 and height > 0
        self._size = vis.Size(width, height)

    def def_path(self, from_: str, to: str, path: list[tuple[float, float]]) -> None:
        self.__visual = None

        # Checking that start and end points of path exists
        if not self._sncreate.is_synapse_start(from_):
            raise ValueError(f"No such neuron, input or output named `{from_}`")
        if not self._sncreate.is_synapse_end(to):
            raise ValueError(f"No such neuron, input or output named `{to}`")

        # converting input token into `in_X`
        if from_ in self._sncreate._inputs:
            from_ = f"in_{self._sncreate.circuit.inputs_id[from_]}"

        # Adding new connection/arrow path to the collection
        if from_ not in self._arrows:
            self._arrows[from_] = {}
        self._arrows[from_][to] = [vis.Pos(*p) for p in path]

    def def_inputs(self, inputs_pos: list[tuple[float, float]]) -> None:
        self.__visual = None
        n_inputs = len(self._sncreate._inputs)
        if n_inputs != len(inputs_pos):
            raise Exception(f'Incorrect number of input positions. There are {n_inputs} '
                            "inputs for the circuit.")
        self._inputs = [vis.Pos(*inpos) for inpos in inputs_pos]

    def def_outputs(self, outputs_pos: list[tuple[float, float]]) -> None:
        self.__visual = None
        n_outputs = len(self._sncreate._outputs)
        if n_outputs != len(outputs_pos):
            raise Exception(f'Incorrect number of output positions. There are {n_outputs} '
                            "outputs for the circuit.")
        self._outputs = [vis.Pos(*outpos) for outpos in outputs_pos]

    def include_visual(self, name: str, visual: vis.CircuitDisplay) -> None:
        self.__visual = None
        if name not in self._sncreate._include_circuit_names:
            raise ValueError(f"No circuit named `{name}` has been included. "
                             "Names of included circuits: "
                             f"{self._sncreate._include_circuit_names}")
        if name in self._include_visuals:
            print(f"Overwriting included circuit visual {name}", file=sys.stderr)
        self._include_visuals[name] = visual
